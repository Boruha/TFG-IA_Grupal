\chapter{Desarrollo y fases del producto}
A lo largo de esta sección comentaremos todo el proceso de desarrollo del prototipo y de la 
memoria, las diferentes iteraciones del producto serán agrupadas en diversas fases con el fin
de facilitar la lectura y el entendimiento de los objetivos planteados en cada momento. Además,
se contarán de forma más extensa los puntos relevantes y objetivos en este proyecto.

\begin{longtable}[c]{|c|c|c|}
\hline
Terminado es esta iteración & Terminado en otra iteración & Sin definir cuando se terminará \\ 
\hline
			(vacio)			&             It.X            &             $\infty$            \\ 
\hline
\caption{Leyenda finalización de tareas.}
\end{longtable}

\section{Fase 0: Definición del proyecto y primeros pasos}
\begin{longtable}[c]{|p{7cm}|c|c|}
\hline
Iteraciones                                               & \% Completado    & Terminado en \\
\hline
\endhead
\textbf{0.1.} Definir la idea.                              & 60\%          & It.2         \\
	\cmidrule[.006pt]{1-3}
\textbf{0.2.} Iniciar desarrollo del prototipo
				Integrar TinyPTC y dibujar por pantalla.    & 100\%         &              \\
	\cmidrule[.006pt]{1-3}
\textbf{0.3.} Adquirir hábito de escribir, preparar
				las herramientas y entorno de LaTex.        & 50\%          & It.2         \\
	\cmidrule[.006pt]{1-3}
\textbf{0.4.} Prototipado del movimiento usando 
				\textit{Steering behavior}.                 & 30\%          & It.1         \\

\cmidrule[1pt]{1-3}

\textbf{1.1.} Creación tipo con coma fija.                  & 100\%         &         \\
	\cmidrule[.006pt]{1-3}
\textbf{1.2.} Busqueda de referentes.                       & 40\%          & It.3    \\
	\cmidrule[.006pt]{1-3}
\textbf{1.3.} Corregir funcionamiento de los
				\textit{Steering behavior} y
				prototipar todos los posibles.              & 100\%         &          \\
	\cmidrule[.006pt]{1-3}
\textbf{1.4.} Sistema de debug visual: vectores.            & 100\%         &          \\ 
	\cmidrule[.006pt]{1-3}
\textbf{1.5.} Herramientras control de ejecución.           & 50\%          & It.7     \\ 

\cmidrule[1pt]{1-3}

\textbf{2.1.} Trabajar más la memoria.                      & 65\%          & $\infty$ \\
	\cmidrule[.006pt]{1-3}
\textbf{2.2.} Terminar de definir idea (GDD).               & 100\%         &          \\
	\cmidrule[.006pt]{1-3}
\textbf{2.3.} Implementar el mínimo producto.               & 20\%          & It.4     \\
	\cmidrule[.006pt]{1-3}
\textbf{2.4.} Experimentación y análisis de resultados.     & 0\%           & It.8     \\
\hline
\caption{Resumen fase 0}
\end{longtable}

Esta primera fase engloba las tres primeras iteraciones donde comenzamos a terminar de definir 
la idea para el proyecto, ya que, todavía era un poco difusa la imagen del producto final que se
quería desarrollar.

\subsection*{Iteración 0: Bucle del juego y primeros sistemas}
Para ir entrando en una dinámica productiva iniciamos el desarrollo de funcionalidades básicas 
como pueden ser el bucle principal del juego, en el cual usamos de la librería \textit{\textless
chrono\textgreater} de C++ para medir y limitar el tiempo entre ejecuciones del bucle acompañado del uso 
de una enumeración que contiene los posibles resultados de un ciclo del juego.

\begin{figure}[htb]
\centering
\includegraphics[width=0.4\textwidth]{imagenes/diario_desarrollo/Loop_juego.png}
\caption{Posibles resultados del bucle de juego.}
\label{fig:game_loop}
\end{figure} 

Una vez tenemos el bucle, toca introducir algo que hacer en el, como primer sistema del juego
encontramos el sistema de dibujado el cual se encargará de crear y manejar la ventana, además
de pintar nuestras entidades y herramientas visuales. Para incluir todas estas funcionalidades
sin añadir librerías pesadas incluiremos \textit{\textless TinyPTC\textgreater} de \newline
\citeauthor*{tinyptc2019}, la cual no 
incluye demasidas funcionalidades u opciones pero nos permitirá trabajar rápido y de forma 
sencilla. Los sprites en un inicio serán simples cuadrados de colores por lo que no requeriremos 
mucho.

Por último, se añadireron las componentes de movimiento e \ac{IA} que, junto a sus correspondientes
sistemas, nos permitirán poder crear un comportamiento de patrulla básico entre puntos fijos.
Además, se terminó la preparación de las herramientas de \LaTeX y `Jabref' para redactar la 
memoria acompañado de la lectura de las directrices, normas y memorias de compañeros del año 
pasado.

\subsection*{Iteración 1: Entero con coma fija e inicio de la IA}
A lo largo de la iteración siguiente, seguimos añadiendo funcionalidades al prototipo como puede 
ser el componente y sistema de \textit{Input}, el cual nos permitirá interactuar con el juego
mediante el mapeado del teclado haciendo uso de la librería \textit{\textless X11\textgreater}
y \textit{\textless TinyPTC\textgreater}.

Una de las herramientas implementadas en el proyecto es el tipo de dato entero con coma fija,
en C++ podemos encontrar el tipo fundamental \textit{float} creado para trabajar con números 
reales, pero si miramos como funcionan exactamente es posible encontar que no es lo que deseamos
exactamente. Los \textit{floats} usan ``precisión simple'' lo cual implica que conforme el número 
sea más grande, la cantidad de bytes destinados a la representación de la parte decimal va 
disminuyendo ofreciendo así menor precisión. Además, trabajar con ellos es más costoso a nivel
computacional\footnote{Esto pasa sobretodo en máquinas que no tengan CPUs con unidades destinadas 
a cálculos en coma flotante} y conllevan un código más pesado debido a la codificación usada 
al ser compilados.

El tipo con coma fija tiene dos partes, en primer lúgar el valor que se quiere reprentar normal
y corriente, y por otro la escala, número que indicará la cantidad de valores disponibles
para la representación decimal. La escala la usaremos para multiplicar o dividir nuestro número
para convertirlo a coma fija, devolverlo sin escalar y/o operaciones con otros números enteros.\\
Es importante elegir una escala adecuada para trabajar de forma eficiente, para ello escogeremos
un número portencia de 2 el cual nos permitirá usar desplazamientos en múltiplicaciones y divisiones,
hacíendo los calculos mucho más rápidos que si tuvieramos que usar las operaciones comunes.

\begin{figure}[htb]
\centering
\includegraphics[width=0.8\textwidth]{imagenes/diario_desarrollo/Entero_fijo.png}
\caption{Ejemplos entero con coma fija.}
\label{fig:fixed}
\end{figure} 

Por otro lado, se comenzó a trabajar en la \ac{IA} del juego creando los primeros comportamientos
y herramientas para alternar entre ellos. Aquí caeremos en los primeros errores de concepto a la
hora de trabajar con los \textit{`Steering behaviors'}, ya que, a la hora de implementar los
usamos un plateamiento y cálculos de movimiento cinético sin aceleración, trabajando directamente 
con la velocidad.\\
En su lugar, lo planteado por la técnica es usar la aceleración de la entidad, de esta forma se 
logrará calcular el movimiento deseado en un momento puntual, enfrentándo lo contra la velocidad 
acumulada. Esto nos proporcionará un movimiento continuado y dinámico en lugar de cambiar drásticamente de 
dirección y velocidad.

\begin{figure}[htb]
\centering
\includegraphics[width=0.35\textwidth]{imagenes/diario_desarrollo/mov1.png}
\caption{Movimiento rectilíneo uniforme.}
\label{fig:mru}
\end{figure} 

\begin{figure}[htb]
\centering
\includegraphics[width=1\textwidth]{imagenes/diario_desarrollo/mov2.png}
\caption{Movimiento rectilíneo acelerado.}
\label{fig:mra}
\end{figure} 

Uno de los comportamientos más sencillos es el \textit{`Arrive'}, el cual nos
llevará a la posición objetivo de forma directa y conforme estemos llegando a esta, la 
acceleración disminuirá parando una vez hayamos llegado al destino. En esta función podremos
apreciar como calculamos la velocidad objetivo en función de la distancia hasta llegar a
la posición objetivo, una vez se calcula se compara con el desplazamiento actual de la entidad
y es la resta de ambas la que nos dará la acceleración necesaria para alcanzar la velocidad
objetivo, siempre controlando que la acceleración y la velocidad no exceden los límites 
marcados.\\
Además, contamos con dos modeficadores adicionales como son el tiempo deseado para alcanzar el
objetivo y un límite de distancia con el objetivo para evitar solapes y/o oscilar sobre el.

\begin{figure}[htb]
\centering
\includegraphics[width=0.75\textwidth]{imagenes/diario_desarrollo/arrive_b.png}
\caption{Diagrama Arrive Behaviour.}
\label{fig:arrive_b}
\end{figure} 

\subsection*{Iteración 2: Herramientas de depuración visual y tiempo de ejecución}
Durante la tercera iteración nos centramos en la mejora de algunos \textit{`Steering behaviors'}
para terminar de hacerlos más fáciles de usar y combinar, con el fin de tener un código más 
limpio y legible, también se mejoró el uso de la coma fija añadiendo más operaciones y ajustando
el funcionamiento.

En cuanto al \textit{'Flocking'}, se comenzó a trabajar en el calculo de las distintas fuerzas que
actuarán sobre las unidades, siendo estas: la atracción al centro de masas del grupo y la separación
de las unidades cercanas. En ambos casos, se recorre el array de entidades aliadas seleccionando las
que se encuentren dentro del radio de influencia, el módulo del vector dependerá de la distancia entre
ambas entidades siendo las más cercanas la que tengan más presencia en la separación y las más lejanas 
en la cohesión, una vez se terminan de acumular todas las direcciones se comprueba que la fuerza 
resultante no es superior al límite.

\begin{figure}[ht]
\centering
\includegraphics[width=0.95\textwidth]{imagenes/diario_desarrollo/flocking.png}
\caption{Esquema fuerzas del flocking}
\label{fig:fuerzas_flocking}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.35\textwidth]{imagenes/diario_desarrollo/linea_ideal.png}
\caption{Esquema algoritmo de Bresenham.}
\label{fig:bresenham}
\end{figure} 

Por otro lado, se añadieron herramientas para debug del movimientos de las entidades y las
diferentes componentes de este, para el dibujado de los vectores se eligió el algoritmo de
`\citeauthor*{Bresenham1962}', ya que, nos permite dibujar rectas de una forma efectiva
y sin consumir muchos recursos. Además, el algoritmo esta diseñado para trabajar con enteros,
cosa que hacemos a lo largo de todo el prototipo. En el esquema~\ref{fig:bresenham} la 
cuadricula blanca representa los pixeles de la plantalla, en color azul la recta ideal que
se busca dibujar y en amarillo la recta resultante del algoritmo.

Otra de las herramientas destinadas a poder análizar el funcionamiento del programa es
el control del tiempo de ejecución y el tamaño del \textit{`DeltaTime'}. Al poder disminuir
el número de fotogramas por segundo, podemos visualizar más detenidamente que sucede en
pantalla y ver que todo va según la previsión, por otra parte se puede aumentar la velocidad
para llegar antes a un punto de la ejecución en concreto. Además, jugar con el tamaño del
\textit{`DeltaTime'} nos permite experimentar con los valores de velocidad y/o otros factores
interpolados para ajustarlos de forma visual. 

Por último en cuanto a implementación, toda la información relacionada con el sistema de 
dibujado y los elementos visuales del juego se trabajan con \textit{uint64\_t}, mientras que
todo lo relacionado con el movimiento y demás calculos físicos se trabajan con
\textit{fint\_t\textless int64\_t\textgreater}. Por ello es necesario usar \textit{``casts``}
sobre los datos físicos con los que se quiera operar en el \textit{Render System}
\footnote{Ya sea la posición en el mapa como el sistema de debug para los vectores de
\textit{Steer}.}, como es una operación recurrente en el código se implementó un sistema 
auxiliar para convertir coordenada continuas (usadas en la mayoría de sistemas) a coordenadas de 
pantalla o pixel. 

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{imagenes/diario_desarrollo/sis_coords.png}\\
\hspace{-8mm} Coordenadas de pantalla. \hspace{16mm}  Coordenadas continuas.
\label{fig:sis_coords}
\end{figure} 

En lo referente a la memoria comenzamos la redacción de una versión preliminar del \ac{GDD}
donde comenzamos a describir las características del producto, del Estado del Arte donde se hace
mención a juegos que nos han servido de inspiración o modelo para imitar y se incluye una explicación
sobre las ténicas y algotimos se van a usar, y la explicación sobre la metodología seguida durante
este desarollo. 

\newpage

\section{Fase 1: Producto mínimo viable}
\begin{longtable}[c]{|p{7cm}|c|c|}
\hline
Iteraciones                                               & \% Completado & Termindo en \\ 
\hline
\endhead
\textbf{3.1.} Cambios en el motor ECS.                     & 100\% &   \\
	\cmidrule[.003pt]{1-3}
\textbf{3.2.} Cambios en el almacenamiento de datos.       & 100\% &   \\ 
	\cmidrule[.003pt]{1-3}
\textbf{3.3.} Cambio tipos propios a template.             & 100\% &   \\ 
	\cmidrule[.003pt]{1-3}
\textbf{3.4.} Cambio en el sistema de clases.              & 100\% &   \\
	
	\cmidrule[1pt]{1-3}

\textbf{4.1.} Añadir referente que use 
				\textit{Steering Behavior}.                & 100\% &   \\
	\cmidrule[.003pt]{1-3}
\textbf{4.2.} Diagrama y explicación de las fases de 
				una iteración.                             & 100\% &   \\
	\cmidrule[.003pt]{1-3}
\textbf{4.3.} Agrupar iteración en fases y describir el
				desarrollo hasta la fecha.                 & 30\%  &  It.5 \\
	\cmidrule[.003pt]{1-3}
\textbf{4.4.} Implementar mínimo producto.                 & 85\%  &  It.6 \\
	\cmidrule[.003pt]{1-3}
\textbf{4.5.} Análisis de resultados del MVP.              & 10\%  &  It.7 \\
	
	\cmidrule[1pt]{1-3}
	
\textbf{5.1.} Crear unidad de ataque a distancia.          & 100\% &   \\
	\cmidrule[.003pt]{1-3}
\textbf{5.2.} Adición de formación en anillo.              & 80\%  &  It.6 \\ 
	\cmidrule[.003pt]{1-3}
\textbf{5.3.} Balanceo de las unidades.                    & 0\%   &  It.8 \\ 
	\cmidrule[.003pt]{1-3}		
\textbf{5.4.} Profundizar los objetivos en el GDD y 
				explicar método de balanceo.               & 0\%   &  It.8 \\ 
	\cmidrule[.003pt]{1-3}		
\textbf{5.5.} Incluir tabla resumen al inicio de fase
				e incluir información extra como el set-up.& 100\%  &  \\

	\cmidrule[1pt]{1-3}

\textbf{6.1.} Experimentar con la formación en anillo
				y fuerzas cuadráticas.                     & 100\% &   \\
	\cmidrule[.003pt]{1-3}
\textbf{6.2.} Sistema de proyectiles para terminar la
				unidad a distancia.                        & 100\% &   \\
	\cmidrule[.003pt]{1-3}
\textbf{6.3.} Remplazar  TinyPTC por Dear ImGUI y
				hacer una interfaz básica.                 & 100\% &   \\
	\cmidrule[.003pt]{1-3}
\textbf{6.4.} Ajustar y continuar con la memoria.          & 80\%  & $\infty$ \\
	\cmidrule[.003pt]{1-3}
\textbf{6.5.} Profundizar en el GDD y listar cuestiones
				tecnológicas que hacen falta.              & 100\% &   \\
\hline
\caption{Resumen fase 1}
\end{longtable}

\subsection*{Iteración 3: Motor ECS y gestión de memoria}
La fase comenzó con una iteración corta debido a las vacaciones de Navidad y final de año, en la
que el foco estuvo despositado en refactorizar y dejar en mejor estado el código desarrollado
hasta el momento, donde se separó el nucleo principal del motor \ac{ECS} del conjunto de sistemas y
herramientas en dos \textit{namespaces} diferentes. 

Por el lado del motor \ac{ECS}, en un primer lugar el almacén de componentes estaba diseñado
para contener punteros a componentes, esto implicaba que los datos de los componentes se
guardaban en la memoria libre de forma ``anárquica''~\ref{fig:memoria_ptr}, 
en su lugar, lo deseado es almacenar todas las componentes de forma contigua para poder utilizar
la caché cuando sea posible, para poder aprovechar que es más rápida y minimizar la cantidad de
veces que mandamos al sistema ir a buscar nuestros datos~\ref{fig:memoria_obj}.

\begin{figure}[htb]
\centering
\includegraphics[width=0.7\textwidth]{imagenes/diario_desarrollo/memoria2.png}\\
\caption{Esquema acceso a vector de punteros.}
\label{fig:memoria_ptr}
\end{figure}

\begin{figure}[hbt]
\centering
\includegraphics[width=0.7\textwidth]{imagenes/diario_desarrollo/memoria1.png}\\
\caption{Esquema acceso a vector de objetos.}
\label{fig:memoria_obj}
\end{figure}

A continuación, se modificó la estructura de las entidades para componerse unicamente de su
\textit{Entity ID} y una serie de \textit{Component ID}s para posibles comprobaciones de que
componentes contiene la entidad, dejando así de tener un puntero a las componentes del almacén.
Esto implica una serie de cambios en la fachada y uso del \textit{Entity manager} a la hora
de crear/eliminar entidades y la obtención de las componentes desde los sistemas a través del
contexto. 

Por último se siguieron modificando los tipos propios, tanto el \textit{fint\_t} como
los \textit{vec2} y \textit{fvec2} para trabajar como plantillas, pudiendo así librarnos de
la necesidad de crear un tipo completo para cada tipo básico con el que queramos usarlos.

\subsection*{Iteración 4: Combate, victoria y derrota}
Durante el mes de enero se implementaron diversas funcionalidades, en primer lugar abordamos
el sistema de combate del juego, para ello se creó una componente para almacenar elementos como
la vida de la unidad, su daño, el rango y el tiempo entre ataques, además, los sistemas de 
ataque para ir restando vida a las unidades conforme reciban daño, el de \textit{cooldown} para
actualizar los temporizadores para volver a atacar, y por último el sistema de muertes donde se
manda a pedir que se borren las entidades que hayan muerto y se realizan las comprobaciones 
de victoria y derrota de la partida.

Una vez se resuelve la partida, en el bucle de ejecución del juego se reiniciarán el nivel
vaciando y volviendo a cargar los elementos del juego.

Para incluir los nuevos sistemas y funcionalidades a la rutina de las unidades, se ha ampliado
el apartado de toma de decisión incluyendo métodos para detectar si hay unidades enemigas 
cerca y seleccionar como objetivo a la más cercana, que en caso de morir se lanzará una nueva
búsqueda. De forma similar, cuando no haya unidades enemigas cercanas se regresará al estado de
patrulla (en caso de la IA) y las manejadas por el jugador volveran a la posición de su
marcador en el mapa. 

En cuanto a la gestión de las unidades en partida, se creó un manejador de equipos donde se gestiona que
unidades pertenecen a cada facción, y proporcionar métodos para obtener los \textit{ID}s de las
unidades por equipo e ir actualizando los equipos cuanda haya bajas. Además de, tener métodos
para crear tipos de unidades en concreto trabajando a la vez de ``fábrica''.

Por otro lado, en el apartado visual, se ha añadido un marcador que indica la dirección a la
que se esta orientando la entidad con el fin de dar \textit{feedback} al jugador y que se 
entienda mejor y de forma visual el desplazamiento o acción actual. Este marcador tiene un 
tamaño relativo al del sprite de la unidad y serán siempre de color blanco para que sea
fácil de identificar. 

\begin{figure}[ht]
\centering
\begin{minipage}[c]{0.42\linewidth}
	\hspace{9mm}
	\includegraphics[width=0.7\textwidth]{imagenes/diario_desarrollo/sin-marcador.png} \\
	\label{sin_marcador}
\end{minipage}
\begin{minipage}[c]{0.40\linewidth}
	\hspace{9mm}
	\includegraphics[width=0.7\textwidth]{imagenes/diario_desarrollo/marcador.png} \\
	\label{marcador}
\end{minipage} \\
	\hspace{0.5cm} Sin marcador. \hspace{3.5cm} Con marcador. 
\caption{Marcador dirección entidad.}
\end{figure}

Por último, en cuanto a la memoria, se ha añadido en el apartado de metodologia la
descripción de las fases que componen una iteración junto a un esquema. Se ha introducido
un tercer referente el cual basa toda su jugabilidad alrededor de los \textit{Steering
behavior}, debido a este juego hemos optado por cambiar la jugabilidad del proyecto
con el fin de imitar la de este juego y con intención de innovar en los controles, como ya se
refleja en el \ac{GDD}, actualmente el jugador no maneja directamente a las unidades con el
ratón ni las selecciona de forma individual, sino que controla un marcador verde el cual será
seguido por sus tropas y mediante ordenenes activará los distintos comportamientos de sus 
unidades. 

\subsection*{Iteración 5: Mecánicas fallidas}
A lo largo de la siguiente iteración se trabajó sobretodo en las mecánicas de juego, con el fin
de acercarse un poco más a la obtención de un prototipo que cumpla con los requisitos del \acs{MVP},
en concreto se comenzó el desarollo de un segundo tipo de unidad basada en ataques a distancia y 
la posibilidad de controlar la formación que siguen nuestras unidades, pudiendo alternar entre un
movimiento sin orden o una formación en anillo.

En cuanto a la unidad a distancia, gracias a que tenemos la componente de combate podemos ajustar de una
forma muy sencilla el rango de ataque de cada unidad, dejándonos la creación de un sistema de proyectiles
como tarea para completar el funcionamiento de dicha unidad. 

Por otro lado encontramos la formación en anillo, la cual cuenta con una primera versión que se basa en
modificar el rango de cohesión al centro del grupo en función de la distacia de ataque. Probando esta forma 
de configurar la posición de las unidades nos hemos dado cuenta de que no muestras buenos resultados en
conjuntos grandes de unidades, ya que, numerosas unidades quedan atrapadas en posiciones incorrectas y la
distribución resultante no es muy optima.

\begin{figure}[htb]
\centering
\includegraphics[width=0.45\textwidth]{imagenes/diario_desarrollo/anillo1.png}\\
\caption{Formación anillo por rango de cohesión}
\label{fig:anillo1}
\end{figure}

Por último, se ha introducido en la memoria una lista con las herramientas que han sido utilizadas 
durante el desarrollo, donde se incluye el nombre de las librerías, la versión y los sistemas sobre los que
puede ser lanzado el juego. Todo con el fin de ayudar a quién quiera utilizar, recompilar y/o 
modificar el prototipo. Además, se ha añadido al comienzo de cada fase una tabla resumen donde se indican
las tareas principales de cada iteración, el portentaje estimado de completado y, en caso de no haber sido
terminada, la iteración donde se ha finalizado.


\subsection*{Iteración 6: Interfaz y Dear ImGUI}
En la cuarta y última iteración de esta fase, el objetivo es el de terminar todas las mecánicas del prototipo
y sustituir \textit{\textless TinyPTC\textgreater} por \textit{\textless Dear ImGUI\textgreater} para poder
centrarnos más adelante en el diseño del nivel/es del prototipo de cara a la entrega final. Además de, poder
añadir alguna funcionalidad extra si es necesario para crear una experiencia de juego mejor.

Llegados a este punto, queremos crear una interfaz y tener la posibilidad de poder añadir algún elemento
visual al proyecto, por lo que necesitamos de una libreria que ofreza más opciones a la hora de trabajar
con ella. En este caso hemos elegido \textit{\textless Dear ImGUI\textgreater}
de \citeauthor*{dearimgui2021}, la cual, propone una nueva
forma de trabajar las interfaces\footnote{\textit{IMGUI (Immediate Mode GUI) paradigm.}} en auge actualmente
y además, nos proporciona una serie de \textit{widgets} y herramientas predefinidas que nos permitirán crear 
un HUD fácil y sencillo.
Además, funciona con \textit{GLFW} y \textit{OpenGL} así que si necesitamos revisar el funcionamiento de
alguna funcionalidad, no tendremos excesivos problemas ya que hemos trabajado con ellas anteriormente.


Para comenzar a trastear con esta librería, hemos implementado una pequeña ventana que nos permitirá manejar
en tiempo real el número de veces que se ejecutará el bucle del juego por segundo y/o el tamaño del 
\textit{DeltaTime}, además tiene un \textit{checkbox} para activar el debug visual del movimiento de las
entidades.

\begin{figure}[htb]
\centering
\includegraphics[width=0.45\textwidth]{imagenes/diario_desarrollo/hudDebug.png}\\
\caption{Herramienta depuración en tiempo de ejecución}
\label{fig:hudDebug}
\end{figure}

Por otro lado, se ha creado una segunda ventana que hará de "minimapa" y mostrará la ubícación de los unidades
tanto aliadas como enemigas y el marcador. Esto nos puede servir de cara a una versión del juego en el que el
mapeado sea más grande que la pantalla, para que nos permita visualizar y ubicarnos en el nivel.

\begin{figure}[htb]
\centering
\includegraphics[width=0.45\textwidth]{imagenes/diario_desarrollo/minimap.png}\\
\caption{Mini Mapa.}
\label{fig:minimap}
\end{figure}

En cuanto a las mecánicas del juego, hemos añadido un sistema de lanzamiento de proyectiles para las unidades
que ataquen a distacia, esto incluye: la creación de las balas siguiendo la orientación del personaje, la
destrucción de las proyectiles una vez alcanzan su distancia máxima y/o impactan contra un objetivo.
La creación y destrucción de entidades se realiza al final del bucle del juego, al igual que con las
demás entidades. 

Un proyectil consiste en una entidad formada por una componente física para su desplazamiento, una para el
calculo de colisiones, y una visual para poder dibujarla. Una vez se lance un proyectil, este seguirá la
dirección que tenía la unidad al momento de disparar, por lo que solo hará daño si la unidad enemiga no 
cambia de posición lo suficiente para esquivar el área de impacto. A la hora de programar las colisiones,
solamente contaremos las unidades del bando contrario para optimizar el número de comprobaciones, para ello
tendrémos un vector de proyectiles por cada bando.

\begin{figure}[htb]
\centering
\includegraphics[width=0.45\textwidth]{imagenes/diario_desarrollo/balas.png}\\
\caption{Demostración sistema de disparos.}
\label{fig:balas}
\end{figure}

Otra de las mecánicas que han sido mejoradas, es la formación en anillo de nuestras unidades. Los resultados
y la forma generada eran poco satisfactorios por lo que se cambió de trabajar con la intensidad de la cohesión
a calcular una posición deseada para cada unidad en relación a su distancia de ataque. Para ello, mediante el
trazado de rayos creamos una recta entre el marcador del jugador y cada una de las distintas unidades, sobre esa
recta se marcará un punto el cual deberá ser alcanzado por la unidad, de esta forma solventamos los solapes entre
unidades y que se queden encerradas en lugares encorrectos, además de ser más escalable en caso de adición de
nuevas unidades en el futuro.

\begin{figure}[ht]
\centering
\begin{minipage}[c]{0.42\linewidth}
	\hspace{9mm}
	\includegraphics[width=0.7\textwidth]{imagenes/diario_desarrollo/anillo2.png} \\
	\label{anillo2}
\end{minipage}
\begin{minipage}[c]{0.42\linewidth}
	\hspace{9mm}
	\includegraphics[width=0.7\textwidth]{imagenes/diario_desarrollo/anillo3.png} \\
	\label{anillo3}
\end{minipage}
\caption{Formación anillo con trazado de rayos.}
\end{figure}

Por último se ha cambiado el cálculo de las fuerzas de cohesión y separación para que tenga un crecimiento
cuadrático en lugar de lineal, de esta forma reducimos su presencia en la media/larga distacia y la aumentamos
en las cercanías.   

\begin{longtable}[c]{|c|c|c|}
\hline
Distancia & Lineal  & Cuadrado \\
\hline
\endhead
40  & \multicolumn{1}{S|}{5.59}   & \multicolumn{1}{S|}{31.25}  \\
\cmidrule[0.15pt]{0-2}
60  & \multicolumn{1}{S|}{2.484}  & \multicolumn{1}{S|}{6.1728} \\ 
\cmidrule[0.15pt]{0-2}
80  & \multicolumn{1}{S|}{1.3975} & \multicolumn{1}{S|}{1.953}  \\ 
\cmidrule[0.15pt]{0-2}
100 & \multicolumn{1}{S|}{0.8944} & \multicolumn{1}{S|}{0.8}    \\
\cmidrule[0.15pt]{0-2}
120 & \multicolumn{1}{S|}{0.621}  & \multicolumn{1}{S|}{0.3858} \\
\cmidrule[0.15pt]{0-2}
140 & \multicolumn{1}{S|}{0.4563} & \multicolumn{1}{S|}{0.2082} \\
\cmidrule[0.15pt]{0-2}
160 & \multicolumn{1}{S|}{0.3494} & \multicolumn{1}{S|}{0.1221} \\
\cmidrule[0.15pt]{0-2}
180 & \multicolumn{1}{S|}{0.2760} & \multicolumn{1}{S|}{0.0762} \\
\cmidrule[0.15pt]{0-2}
200 & \multicolumn{1}{S|}{0.2236} & \multicolumn{1}{S|}{0.05}   \\
\cmidrule[0.15pt]{0-2}
220 & \multicolumn{1}{S|}{0.1848} & \multicolumn{1}{S|}{0.0342} \\
\hline
\caption{Fuerzas de separación en función de la distancia}
\end{longtable}

\newpage

\section{Fase 3: Últimos pasos}
\begin{longtable}[c]{|p{7cm}|c|c|}
\hline
Iteraciones                                                & \% Completado & Termindo en \\ 
\hline
\endhead
\textbf{7.1.} Continuar trabajando el GDD.                 & 10\% & It.X  \\
	\cmidrule[.003pt]{1-3}
\textbf{7.2.} Ajustes de valores de daño y vida.           &  0\% & It.X  \\ 
	\cmidrule[.003pt]{1-3}
\textbf{7.3.} Incluir los ciclos de análisis de los 
				comportamientos resultantes y 
				propuestas de mejora                       & 40\% & It.X  \\ 
	\cmidrule[.003pt]{1-3}
\textbf{7.4.} Revisar bugs y comportamientos erróneos.     & 100\% & \\
	\cmidrule[.003pt]{1-3}
\textbf{7.5.} Incluir sistema de cámara y coordenadas 
				de mundo.                                  & 100\% & \\
	\cmidrule[.003pt]{1-3}
\textbf{7.6.} Implementar jugabilidad básica: debe poder
				jugarse una partida simple al juego, con
				las reglas propuestas.                     & \% & It.X  \\

		\cmidrule[1pt]{1-3}

\textbf{8.1.} Balanceo de unidades y ajustar sus valores.  & \% &  \\
	\cmidrule[.003pt]{1-3}
\textbf{8.2.} Redactar de forma detallada el balanceo.     & \% &  \\
	\cmidrule[.003pt]{1-3}
\textbf{8.3.} Prueba de compilación cruzada para Windows.  & \% &  \\
	\cmidrule[.003pt]{1-3}
\textbf{8.4.} Describir todas las herramientas implementadas
				y procesos de analasis.                    & \% &  \\
\hline
\caption{Resumen fase 3}
\end{longtable}

\subsection*{Iteración 7: Terminando las cuestiones tecnológicas}
A lo largo de esta iteración los objetivos propuestos eran los de terminar de implementar y/o corregir
las mecánicas y sistemas del proyecto, a la vez que se continua en la redacción de la memoria y el GDD.
De esta forma poder dejar las ultimas iteraciones en diseñar los niveles, balancear el juego y terminar
de redactar la memoria.

Uno de los puntos principales cae sobre la resolución de un error en las colisiones de las balas,
este problema consistía en una serie de balas que atravesaban a las unidades con baja frecuencía
y sin motivo aparente. Con el fin de subsanar este problema se ha creado una componente de colisiones
la cual ha sustituido el uso del tamaño del sprite en los calculos de colisiones con el límite de la 
ventana y demás entidades. \\
Al integrar esta componente en el sistema de debug visual pudimos observar como el problema era que las
colisiones estan siendo calculadas teniendo en cuenta el centro de la entidad, cuando el origen de ésta
es la esquina superior izquierda, esto suponía un desplazamiento de todas las colisiones y por lo tanto
errores en las detección, con cambiar ese factor se solucionaron todos los problemas.

A lo largo de la ejecución del programa, podíamos ver como algunas unidades se quedaban quietas sin poder
retomar su movimiento hasta que otra unidad la desplazaba y hacía reaccionar, después de analizar la situación
pudimos determinar que el problema ocurría cuando la unidad perdía su velocidad y aceleración dentro del
rango de ``velocidad reducida'' del \textit{`Arrive behaviour'}, lo que estaba sucediendo, es que no se
estaban calculando correctamente las divisiones con enteros de coma fija cuyo resultado era un valor
entre 0 y 1.

\begin{figure}[ht]
\centering
\includegraphics[width=0.45\textwidth]{imagenes/diario_desarrollo/division_entera.png}\\
\caption{Comparación resultados división.}
\label{fig:div_int}
\end{figure}

En una primera versión del operador, el cálculo que se realizaba era: dividir primero los valores a operar
y después multiplicar el resultado por la `Escala', este orden de los factores nos llevaba a que si, en la
primera operación el divisor era mayor que el dividendo, el valor del resto era 0, ya que trabajamos
con enteros y trunca los valores decimales.

Para solucionar el problema, lo que se hizo fue extraer una versión reducida del tipo de dato que sólo contaba
con las operaciones de división e introducirla en `Godbolt'\footnote{\url{https://godbolt.org}}, para poder
realizar una serie de pruebas y ajustes rápidamente sin tener que estar pendiente del resto del proyecto. \\
Una vez teníamos ya las funciones listas, lo único que quedaba era experimentar con el orden de los
factores a la hora de realizar la operación y ver si el resultado variaba. Tras un ligero ajuste conseguimos
que la operación conservara el valor deseado, esto se logró multiplicando el primer valor de la operación
por la `Escala' antes de dividir por el segundo dígito, de esta forma evitamos los resultados entre 0 y 65536
y que se trunque el valor en mitad de la operación.

Una vez solventados los errores, nos pusimos a crear lo necesario para poder diseñar niveles más amplios,
para ello incluímos un sistema de cámaras, el cual mostrará la porción del nivel donde se encuentre
nuestro puntero y unidades, el seguimiento se hace utilizando el \textit{`Arrive behaviour'} de forma que
el movimiento de la cámara comienza cuando nos separamos una cierta distancia del centro de la escena.

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{imagenes/diario_desarrollo/camara.png}\\
\caption{Arrive behaviour en la cámara}
\label{fig:arrive_cam}
\end{figure}

Ahora las dimensiones de la pantalla pasan a ser las de la cámara y el nivel tendrá unas dimensiones
propias, las cuales usaremos para limitar el movimiento de las unidades, por lo que las unidades se pueden
mover libremente fuera de nuestro campo de visión siempre y cuando estén en los límites del nivel,
mientras estén fuera de cámara solo se dibujaran en el minimapa para evitar hacer llamadas inútiles. \\
Además de los cálculos para las colisiones, otro requisito fue adaptar el minimapa para que mostrara
que parte del nivel esta siendo visualizado y que nos permita úbicar a todas las unidades y objetivos
fuera de cámara. Un detalle importante es que al crear el nivel, le indicamos al motor la relación
entre las dimensiones de pantalla y nivel, por lo que los objetos mostrados en el minimapa se ajustarán
en función de este parámetro, cuanto más grande el nivel, más pequeños serán los elementos.

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{imagenes/diario_desarrollo/minimap2.png}\\
\caption{Cambios en el minimapa}
\label{fig:minimap2}
\end{figure}

En lo referente al \textit{HUD}, se ha añadido también un selector de comportamiento y formación
para nuestras unidades, de esta forma podremos controlar dichos parametros con simples \textit{clicks}
y ahorrarnos el tener que disponer de una tecla para cada opción. 

\begin{figure}[ht]
\centering
\includegraphics[width=0.45\textwidth]{imagenes/diario_desarrollo/eleccion_b.png}\\
\caption{Selector de comportamiento y formación}
\label{fig:hud_selec}
\end{figure}

En lo referente a la mecánicas y comportamientos de las entidades han habido dos cambios relevantes durante
la iteración, en primer lugar encontramos la adición de un componente \textit{singleton} de \textit{Blackboard}
el cual nos permitirá almacenar información compartida para todas las unidades bajo nuestro control, además de
controlar la frecuencia en la que la esta información se actualiza, esto nos permitirá crear una sensación
de retraso en la reacción a nuestras acciones por parte de las unidades a la vez que nos permite eliminar
la necesidad de guardar la misma información en cada componente de \ac{IA} por unidad que tengamos.

En segundo lugar encontramos otro cambio en las componentes de \ac{IA}, esta vez con efectos sobre las unidades
controladas por la máquina, en este caso se trata de la creación de una estructura auxiliar que representa 
y contiene las rutas que las unidades seguirán mientras no estén peleando contra nosotros.

En un inicio estas rutas se encontraban directamente en la componente, actualmente en la componente podemos
encontrar un ``iterador de ruta'' el cual nos podrá facilitar la siguiente posición y gestionar como avanzamos
por la patrulla, de forma que si llegamos al final de forma automática nos devolverá la primera posición
que recorrimos. De esta forma evitamos errores en la gestión de las patrullas y dublicar la información de estas.
 

